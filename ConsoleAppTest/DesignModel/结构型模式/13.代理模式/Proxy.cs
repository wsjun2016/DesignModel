using System;
using System.Collections.Generic;
using System.Text;

namespace DesignModel.结构型模式._13.代理模式 {
    //代理模式
    //为某个对象提供一种代理，以控制对这个对象的访问
    //可以对 远程或异地的 对象 使用代理模式，使得可以在本地进行访问，如Internet代理。也可以对复杂对象使用代理模式，使得可以更方便的调用

    //角色
    //服务接口（Service Interface）声明了服务接口。代理必须遵循该接口才能伪装成服务对象。
    //服务（Service）类提供了一些实用的业务逻辑。
    //代理（Proxy）类包含一个指向服务对象的引用成员变量。代理完成其任务（例如延迟初始化、记录日志、访问控制和缓存等）后会将请求传递给服务对象。通常情况下，代理会对其服务对象的整个生命周期进行管理。
    //客户端（Client） 能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理。

    //代理模式按照使用目的可以分为以下几种：
    //1）远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是本电脑中，也可以在另一台电脑中。最典型的例子就是--客户端调用Web服务或WCF服务。
    //2）虚拟（Virtual）代理：根据需要创建一个资源消耗较大的对象，使得对象只在需要时才会被真正创建。
    //3）Copy-on-Write代理：虚拟代理的一种，把复制（或者叫克隆）拖延到只有在客户端需要时，才真正采取行动。
    //4）保护（Protect or Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。
    //5）防火墙（Firewall）代理：保护目标不让恶意用户接近。
    //6）智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。
    //7）Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以这些结果。
    //在上面所有种类的代理模式中，虚拟代理、远程代理、智能引用代理和保护代理较为常见的代理模式。

    //应用场景
    //使用代理模式的方式多种多样，我们来看看最常见的几种。
    //延迟初始化（虚拟代理）。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。
    //  你无需在程序启动时就创建该对象，可将对象的初始化延迟到真正有需要的时候。
    //访问控制（保护代理）。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序（包括恶意程序），此时可使用代理模式。
    //  代理可仅在客户端凭据满足要求时将请求传递给服务对象。
    //本地执行远程服务（远程代理）。适用于服务对象位于远程服务器上的情形。
    //  在这种情形中，代理通过网络传递客户端请求，负责处理所有与网络相关的复杂细节。
    //记录日志请求（日志记录代理）。适用于当你需要保存对于服务对象的请求历史记录时。代理可以在向服务传递请求前进行记录。
    //  缓存请求结果（缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时。
    //  代理可对重复请求所需的相同结果进行缓存，还可使用请求参数作为索引缓存的键值
    //智能引用。可在没有客户端使用某个重量级对象时立即销毁该对象。
    //  代理会将所有获取了指向服务对象或其结果的客户端记录在案。代理会时不时地遍历各个客户端，检查它们是否仍在运行。如果相应的客户端列表为空，代理就会销毁该服务对象，释放底层系统资源。
    //代理还可以记录客户端是否修改了服务对象。其他客户端还可以复用未修改的对象。

    //实现方式
    //1.如果没有现成的服务接口，你就需要创建一个接口来实现代理和服务对象的可交换性。从服务类中抽取接口并非总是可行的，因为你需要对服务的所有客户端进行修改，让它们使用接口。备选计划是将代理作为服务类的子类，这样代理就能继承服务的所有接口了。
    //2.创建代理类，其中必须包含一个存储指向服务的引用的成员变量。通常情况下，代理负责创建服务并对其整个生命周期进行管理。在一些特殊情况下，客户端会通过构造函数将服务传递给代理。
    //3.根据需求实现代理方法。在大部分情况下，代理在完成一些任务后应将工作委派给服务对象。
    //4.可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法，也可以创建一个完整的工厂方法。
    //5.可以考虑为服务对象实现延迟初始化。


    //第一种：使用引用依赖的方式代理某个对象
    //假如异地有一个MyMath类，我们可以将之组合在代理类中，使得在本地可以很方便的进行调用
    public class MathProxy
    {
        //被代理的对象
        private readonly IMyMath math=new MyMath();

        //代理Math.Max方法
        public int Max(int a,int b)
        {
            return math.Max(a,b);
        }

        //代理Math.Min方法
        public int Min(int a,int b)
        {
            return math.Min(a, b);
        }
    }


    //第二种：继承某个对象的接口，并引用该接口，强制代理所有方法
    public interface IMyMath
    {
        int Max(int a,int b);
        int Min(int a,int b);
        int Add(int a, int b);
    }

    public class MyMath : IMyMath
    {
        public int Add(int a, int b) => a + b;

        public int Min(int a, int b) => Math.Min(a, b);

        public int Max(int a, int b) => Math.Max(a, b);
    }

    //代理类
    public class MyMathProxy : IMyMath
    {
        //被代理的对象
        private readonly IMyMath math = new MyMath();

        //以下是被强制代理的所有方法

        public int Add(int a, int b)
        {
            return math.Add(a, b);
        }        

        public int Max(int a, int b)
        {
            return math.Max(a, b);
        }

        public int Min(int a, int b)
        {
            return math.Min(a, b);
        }
    }














}
